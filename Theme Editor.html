<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>GOAT Theme Editor</title>
    <link rel="icon"
        href="data:image/png;base64,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"
        type="image/x-icon">

    <style>
        :root {
            /* Dark Theme (default) */
            --bg-body: #282828;
            /* Overall page background */
            --bg-input: #222222;
            /* Background for text inputs */
            --bg-main: var(--bg-body);
            /* Background of the main content area */
            --bg-palette-container: #1e1e1e;
            /* Background for the color palette squares */
            --bg-sidebar: #232323;
            /* Sidebar background */
            --bg-theme-item-list: #232323;
            /* Background for the list of theme color items */
            --bg-theme-item-row-hover: #3a3a3a;
            /* Background of a theme item row on hover */
            --border-medium: #333333;
            /* A medium-strength border color */
            --border-strong: #444444;
            /* A stronger border color */
            --button-bg-disabled: #333333;
            /* Background color for disabled buttons */
            --button-bg-hover: #666666;
            /* Button background on hover */
            --button-bg: #444444;
            /* Default button background */
            --button-text-disabled: #888888;
            /* Text color for disabled buttons */
            --button-text: #ffffff;
            /* Default button text color */
            --selected-palette-border: #ffb347;
            /* Border for selected palette color (dark theme) */
            --selected-palette-shadow: #ffb34744;
            /* Shadow for selected palette color (dark theme) */
            --text-body: #d3d3d3;
            /* Main text color for the body */
            --text-filename-display: #aaaaaa;
            /* Color for displaying file names */
            --text-input: var(--text-body);
            /* Text color for inputs */
            --text-title: var(--text-body);
            /* Color for main titles (like H1) */
        }

        body.light-theme {
            --bg-body: #eeeeee;
            --bg-input: #ffffff;
            --bg-main: var(--bg-body);
            --bg-palette-container: #f0f0f0;
            --bg-sidebar: #f5f5f5;
            --bg-theme-item-list: #f5f5f5;
            --bg-theme-item-row-hover: #e0e0e0;
            --border-medium: #dddddd;
            --border-strong: #cccccc;
            --button-bg-disabled: #e0e0e0;
            --button-bg-hover: #bbbbbb;
            --button-bg: #cccccc;
            --button-text-disabled: #aaaaaa;
            --button-text: #333333;
            --selected-palette-border: #007bff;
            /* Border for selected palette color (light theme) */
            --selected-palette-shadow: #007bff44;
            /* Shadow for selected palette color (light theme) */
            --text-body: #333333;
            --text-filename-display: #777777;
            --text-input: var(--text-body);
            --text-title: var(--text-body);
        }

        body {
            background: var(--bg-body);
            color: var(--text-body);
            font-family: 'Source Code Pro', monospace;
            font-size: 16px;
            margin: 0;
            min-height: 98vh;
            transition: background 0.3s, color 0.3s;
        }

        .container {
            display: flex;
            flex-direction: row;
            height: 98vh;
        }

        .sidebar {
            background: var(--bg-sidebar);
            padding: 24px 16px 16px 16px;
            width: 550px;
            border-right: 1px solid var(--border-strong);
            display: flex;
            flex-direction: column;
            gap: 16px;
            transition: background 0.3s, border-color 0.3s;
            flex-shrink: 0;
            /* Prevent sidebar from shrinking if main content is wide */
        }

        .main {
            flex-grow: 1;
            /* Allow main to take remaining space */
            padding: 32px;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            max-height: 98vh;
            background: var(--bg-main);
            transition: background 0.3s;
            overflow-x: auto;
            /* Allow main content area to scroll horizontally if #themeColors gets too wide */
            min-width: 0;
            /* Important for flex children that need to shrink */
        }


        h1 {
            font-size: 2rem;
            margin-bottom: 16px;
            letter-spacing: 1px;
            color: var(--text-title);
        }

        .theme-toggle-button {
            background: var(--button-bg);
            color: var(--button-text);
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s, color 0.2s;
            margin-bottom: 10px;
            align-self: flex-start;
        }

        .theme-toggle-button:hover {
            background: var(--button-bg-hover);
        }

        .file-inputs {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .file-input-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .import-btn {
            background: var(--button-bg);
            color: var(--button-text);
            border: none;
            border-radius: 4px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.2s, color 0.2s;
            flex-shrink: 0;
        }

        .import-btn:hover {
            background: var(--button-bg-hover);
        }

        .file-name-display {
            color: var(--text-filename-display);
            font-size: 0.85rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-grow: 1;
        }


        .filter-row {
            margin: 12px 0 0 0;
            display: flex;
            gap: 8px;
        }

        #filterInput {
            flex: 1;
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid var(--border-strong);
            background: var(--bg-input);
            color: var(--text-input);
            transition: background 0.3s, color 0.3s, border-color 0.3s;
        }

        #bulkAssignBtn,
        #exportBtn {
            background: var(--button-bg);
            color: var(--button-text);
            border: none;
            border-radius: 4px;
            padding: 8px 16px;
            margin-top: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: background 0.2s, color 0.2s;
        }

        #bulkAssignBtn:disabled,
        #exportBtn:disabled {
            background: var(--button-bg-disabled);
            color: var(--button-text-disabled);
            cursor: not-allowed;
        }

        #bulkAssignBtn:hover:not(:disabled),
        #exportBtn:hover:not(:disabled) {
            background: var(--button-bg-hover);
        }

        #paletteColors {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            max-height: 460px;
            overflow-y: auto;
            background: var(--bg-palette-container);
            border-radius: 4px;
            padding: 8px;
            margin: 8px 0;
            border: 1px solid var(--border-medium);
            transition: background 0.3s, border-color 0.3s;
        }

        .palette-color {
            border: 2px solid var(--border-strong);
            border-radius: 4px;
            cursor: pointer;
            display: inline-block;
            height: 42px;
            width: 42px;
            margin: 0;
            transition: border 0.2s, transform 0.1s, border-color 0.3s;
        }

        .palette-color.selected {
            border: 2px solid var(--selected-palette-border);
            box-shadow: 0 0 0 2px var(--selected-palette-shadow);
            transform: scale(1.08);
        }

        .palette-color:hover {
            border: 2px solid var(--button-bg-hover);
        }

        button {
            width: fit-content;
        }


        #themeColors {
            /* Container for all .color-row elements */
            border: 1px solid var(--border-strong);
            flex-grow: 1;
            background: var(--bg-theme-item-list);
            border-radius: 4px;
            padding: 8px 0;
            /* Vertical padding for the list container */
            min-height: 0;
            /* Essential for flex children that need to scroll */
            transition: background 0.3s, border-color 0.3s;
            overflow-y: auto;
            /* Vertical scrolling for the list of rows */
            overflow-x: auto;
            /* Horizontal scrolling if a single row becomes too wide */
        }

        .color-row {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-medium);
            box-sizing: border-box;
        }

        .color-row:hover {
            background: var(--bg-theme-item-row-hover);
        }

        .color-row:last-child {
            border-bottom: none;
        }

        .color-sample {
            /* The color swatch */
            border: 1px solid var(--border-strong);
            height: 42px;
            width: 42px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            /* For the hidden color input */
            box-sizing: border-box;
            flex-shrink: 0;
            /* Prevent swatch from shrinking */
        }

        /* Styles for the text spans within .color-row */
        .color-row>span {
            text-align: left;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 160px;
            padding: 2px 0;
            margin: 0 10px;
            max-width: 280px;
        }

        .color-row>span:nth-child(2) {
            flex-shrink: 1;
            max-width: 340px;
            min-width: 280px;
            text-align: left;
        }

        .color-row>span:nth-child(3) {
            flex-shrink: 1;
            max-width: 320px;
            min-width: 0;
            text-align: left;
        }

        .color-row>span:nth-child(4) {
            flex-shrink: 1;
            min-width: 140px;
            max-width: 340px;
            text-align: left;
            overflow: visible;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="sidebar">
            <div>
                <h1>GOAT Theme Editor</h1>
                <button id="themeToggleBtn" class="theme-toggle-button">Toggle Light or Dark</button>
            </div>
            <div class="file-inputs">
                <div class="file-input-row">
                    <button id="importPaletteBtn" class="import-btn">Import Palette</button>
                    <span id="paletteFileName" class="file-name-display">No palette file selected</span>
                    <input type="file" id="paletteFile" accept=".xml" style="display: none;">
                </div>
                <div class="file-input-row">
                    <button id="importThemeBtn" class="import-btn">Import Theme</button>
                    <span id="themeFileName" class="file-name-display">No theme file selected</span>
                    <input type="file" id="themeFile" accept=".xml" style="display: none;">
                </div>
            </div>
            <div class="filter-row">
                <input type="text" id="filterInput" placeholder="Filter by name...">
            </div>
            <button id="bulkAssignBtn" disabled>Bulk Assign Selected Color</button>
            <div id="paletteColors"></div>

            <button id="exportBtn" disabled>Export Updated XML</button>
        </div>
        <div class="main">
            <div id="themeColors">
            </div>
        </div>
    </div>


    <script>
        /*
        GOAT Theme Editor
        Allows importing theme XML files and color palettes, editing colors, and exporting the updated theme XML.
        Utilizes GoatColor for color parsing and manipulation.
        */

        // --- State Variables ---
        let palette = [];
        let themeItems = [];
        let filteredThemeItems = [];
        let selectedPaletteColor = null;
        let themeFileDoc = null;
        let originalThemeFileName = "Theme";

        // --- Editor UI Theme Management ---
        const themeToggleBtn = document.getElementById('themeToggleBtn');

        function applyTheme(themeName) {
            if (themeName === 'light') {
                document.body.classList.add('light-theme');
                localStorage.setItem('themeEditorTheme', 'light');
            } else {
                document.body.classList.remove('light-theme');
                localStorage.setItem('themeEditorTheme', 'dark');
            }
            // Re-render palette and theme items if they are already loaded to reflect theme changes
            if (typeof renderPalette === 'function' && (palette.length > 0 || document.getElementById('paletteColors').innerHTML.includes('palette-color'))) {
                renderPalette();
            }
            if (typeof renderThemeItems === 'function' && (filteredThemeItems.length > 0 || themeItems.length > 0)) {
                renderThemeItems();
            }
        }

        // --- Color Parsing and Formatting ---
        function parseColorString(str) {
            if (typeof str !== 'string') return null;
            str = str.trim();
            let originalInputFormat = null;
            let originalPrefix = "";
            let originalUsesCommas = false;
            let originalHadExplicitAlpha = false;
            const lowerStr = str.toLowerCase();

            if (lowerStr.startsWith('#') || /^(0x)?[0-9a-f]+$/i.test(str)) {
                originalInputFormat = "hex";
                if (str.startsWith('#')) originalPrefix = "#";
                else if (lowerStr.startsWith('0x')) originalPrefix = str.substring(0, 2);
                const hexContent = str.replace(/^#|^0x/i, '');
                if (hexContent.length === 4 || hexContent.length === 8 || (hexContent.length === 10 && lowerStr.startsWith('0x'))) {
                    originalHadExplicitAlpha = true;
                }
            } else if (lowerStr.startsWith("rgb")) {
                originalInputFormat = "rgb";
                originalPrefix = str.substring(0, lowerStr.indexOf('('));
                if (str.includes(',')) originalUsesCommas = true;
                if (str.includes('/') || (originalPrefix.toLowerCase() === 'rgba' && str.split(originalUsesCommas ? ',' : ' ').length > 3)) {
                    originalHadExplicitAlpha = true;
                }
            } else if (lowerStr.startsWith("hsl")) {
                originalInputFormat = "hsl";
                originalPrefix = str.substring(0, lowerStr.indexOf('('));
                if (str.includes(',')) originalUsesCommas = true;
                if (str.includes('/') || (originalPrefix.toLowerCase() === 'hsla' && str.split(originalUsesCommas ? ',' : ' ').length > 3)) {
                    originalHadExplicitAlpha = true;
                }
            } else if (lowerStr.startsWith("oklch")) {
                originalInputFormat = "oklch";
                originalPrefix = str.substring(0, lowerStr.indexOf('('));
                if (str.includes('/')) originalHadExplicitAlpha = true;
            }

            const gc = new GoatColor(str); // GoatColor should be globally available.
            if (gc.isValid()) {
                const rgb = gc.toRgb(); // { r, g, b }
                const rHex = Math.round(rgb.r).toString(16).padStart(2, '0');
                const gHex = Math.round(rgb.g).toString(16).padStart(2, '0');
                const bHex = Math.round(rgb.b).toString(16).padStart(2, '0');
                const internalHex = (rHex + gHex + bHex).toUpperCase();
                return {
                    hex: internalHex, alpha: gc.a, // GoatColor instance has 'a' property
                    goatColor: gc, // Store the GoatColor instance
                    originalString: str,
                    inputFormat: originalInputFormat || "unknown", // GoatColor doesn't expose _format
                    originalPrefix: originalPrefix, originalUsesCommas: originalUsesCommas,
                    originalHadExplicitAlpha: originalHadExplicitAlpha,
                };
            }
            return null;
        }

        function formatColorForOutput(colorInfo) {
            if (!colorInfo || !colorInfo.goatColor || !colorInfo.goatColor.isValid()) {
                return colorInfo && typeof colorInfo.originalString === 'string' ? colorInfo.originalString : "#000000";
            }
            const gc = colorInfo.goatColor;
            const inputFormat = colorInfo.inputFormat;
            const originalPrefix = colorInfo.originalPrefix || "";
            const usesCommas = colorInfo.originalUsesCommas; // This implies legacy format for RGB/HSL
            const outputAlpha = colorInfo.originalHadExplicitAlpha || gc.a < 1 ||
                (originalPrefix.toLowerCase().endsWith('a') && originalPrefix.length > 3);
            let outputString = "";

            switch (inputFormat) {
                case "hex":
                    const originalHexContent = colorInfo.originalString.replace(/^#|^0x/i, '');
                    const isShortHexLen = originalHexContent.length === 3 || originalHexContent.length === 4;
                    if (outputAlpha) {
                        const shortHexa = gc.toHexaShort();
                        outputString = isShortHexLen && shortHexa ? shortHexa : gc.toHexa();
                    } else {
                        const shortHex = gc.toHexShort();
                        outputString = isShortHexLen && shortHex ? shortHex : gc.toHex();
                    }
                    if (originalPrefix.toLowerCase() === "0x") {
                        if (outputString.startsWith("#")) { // GoatColor hex output always starts with #
                            if (outputString.length === 9) { // #RRGGBBAA from GoatColor
                                outputString = originalPrefix + outputString.substring(7, 9) + outputString.substring(1, 7); // 0x + AA + RRGGBB
                            } else if (outputString.length === 5 && outputString.charAt(0) === '#') { // #RGBA from GoatColor
                                const r = outputString[1] + outputString[1]; const g = outputString[2] + outputString[2]; const b = outputString[3] + outputString[3]; const a_val = outputString[4] + outputString[4];
                                outputString = originalPrefix + a_val + r + g + b; // 0x + AA + RR + GG + BB
                            } else { // e.g. #RRGGBB
                                outputString = originalPrefix + outputString.substring(1); // 0xRRGGBB
                            }
                        }
                    } else if (originalPrefix === "" && outputString.startsWith("#")) {
                        outputString = outputString.substring(1); // Remove # if original had no prefix
                    } else if (originalPrefix === "#" && !outputString.startsWith("#")) {
                        // This case should not be hit if outputString is from GoatColor hex methods
                        outputString = "#" + outputString;
                    }
                    break;
                case "rgb":
                    let rgbBaseString = outputAlpha ? gc.toRgbaString(usesCommas) : gc.toRgbString(usesCommas);
                    if (originalPrefix && rgbBaseString.toLowerCase().startsWith(originalPrefix.toLowerCase())) {
                        outputString = originalPrefix + rgbBaseString.substring(originalPrefix.length);
                    } else if (originalPrefix && outputAlpha && originalPrefix.toLowerCase() === "rgb" && rgbBaseString.toLowerCase().startsWith("rgba")) {
                        // Handle case where original was `rgb(...)` but alpha implies `rgba(...)`
                        let newPrefixAttempt = originalPrefix + "a";
                        if (rgbBaseString.toLowerCase().startsWith(newPrefixAttempt.toLowerCase())) {
                            outputString = newPrefixAttempt + rgbBaseString.substring(newPrefixAttempt.length);
                        } else { outputString = rgbBaseString; } // Fallback if prefix logic is complex
                    } else { outputString = rgbBaseString; }
                    break;
                case "hsl":
                    let hslBaseString = outputAlpha ? gc.toHslaString(usesCommas) : gc.toHslString(usesCommas);
                    if (originalPrefix && hslBaseString.toLowerCase().startsWith(originalPrefix.toLowerCase())) {
                        outputString = originalPrefix + hslBaseString.substring(originalPrefix.length);
                    } else { outputString = hslBaseString; }
                    break;
                case "oklch":
                    outputString = outputAlpha ? gc.toOklchaString() : gc.toOklchString();
                    break;
                default: // "unknown" or other formats
                    outputString = gc.toString("auto"); // GoatColor's "auto" prefers short hex
                    if (outputString.startsWith("#")) { // Apply 0x or no-prefix logic if needed
                        if (originalPrefix.toLowerCase() === "0x") {
                            if (outputString.length === 9) { // #RRGGBBAA from GoatColor
                                outputString = originalPrefix + outputString.substring(7, 9) + outputString.substring(1, 7);
                            } else { outputString = originalPrefix + outputString.substring(1); }
                        } else if (originalPrefix === "") {
                            outputString = outputString.substring(1);
                        }
                    }
                    break;
            }
            return outputString;
        }

        function normalizeHex(hexInput) {
            const gc = new GoatColor(hexInput);
            return gc.isValid() ? gc.toHex().substring(1).toUpperCase() : '000000';
        }

        // --- Contrast Calculation Helpers ---
        function getRelativeLuminance(colorString) {
            const color = new GoatColor(colorString);
            if (!color.isValid()) return 0;
            const rgb = color.toRgb(); // { r, g, b }
            const sRGB = [rgb.r, rgb.g, rgb.b].map(function (val) { const s = val / 255; return (s <= 0.03928) ? s / 12.92 : Math.pow((s + 0.055) / 1.055, 2.4); });
            return 0.2126 * sRGB[0] + 0.7152 * sRGB[1] + 0.0722 * sRGB[2];
        }
        function calculateContrastRatio(color1String, color2String) { const l1 = getRelativeLuminance(color1String); const l2 = getRelativeLuminance(color2String); return (l1 > l2) ? (l1 + 0.05) / (l2 + 0.05) : (l2 + 0.05) / (l1 + 0.05); }

        // --- UI Update Functions ---
        function updateButtonStates() {
            const bulkAssignBtn = document.getElementById('bulkAssignBtn');
            const exportBtn = document.getElementById('exportBtn');
            if (!bulkAssignBtn || !exportBtn) {
                console.error("updateButtonStates: bulkAssignBtn or exportBtn not found.");
                return;
            }
            const hasColorItems = themeItems.some(it => it.isColor);
            exportBtn.disabled = !themeFileDoc || !hasColorItems;
            bulkAssignBtn.disabled = !(selectedPaletteColor && filteredThemeItems.some(it => it.isColor));
        }

        // --- Core Parsing Functions ---
        function parsePalette(xml) {
            const doc = new DOMParser().parseFromString(xml, 'application/xml');
            if (doc.documentElement.nodeName === 'parsererror') { console.error('Palette XML error:', doc.documentElement.textContent); alert('Error: Invalid Palette XML.'); return []; }
            return Array.from(doc.getElementsByTagName('myColor')).map(e => ({ name: e.getAttribute('name') || 'Unnamed', hex: normalizeHex(e.getAttribute('hexvalue') || '') }));
        }

        function parseGenericThemeFile(xml) {
            const doc = new DOMParser().parseFromString(xml, 'application/xml');
            if (doc.documentElement.nodeName === 'parsererror') { console.error('Theme XML error:', doc.documentElement.textContent); alert('Error: Invalid Theme XML.'); return { doc: null, items: [] }; }
            const items = [];
            function traverse(node) {
                if (node.nodeType !== Node.ELEMENT_NODE) return;
                if (node.attributes) {
                    for (let i = 0; i < node.attributes.length; i++) {
                        const attr = node.attributes[i];
                        const parsedColor = parseColorString(attr.value);
                        if (parsedColor) {
                            const styleNameAttribute = node.getAttribute('name');
                            const itemName = styleNameAttribute ? `${styleNameAttribute}[${attr.name}]` : `${node.nodeName}[${attr.name}]_idx${items.length}`;
                            items.push({ name: itemName, currentColorHex: parsedColor.hex, colorInfo: parsedColor, el: node, attributeName: attr.name, isColor: true });
                        }
                    }
                }
                let hasElementChildren = false;
                for (let k = 0; k < node.childNodes.length; k++) { if (node.childNodes[k].nodeType === Node.ELEMENT_NODE) { hasElementChildren = true; traverse(node.childNodes[k]); } }
                if (!hasElementChildren && node.textContent) {
                    const textContent = node.textContent.trim();
                    if (textContent) {
                        const parsedColor = parseColorString(textContent);
                        if (parsedColor) { items.push({ name: `${node.nodeName}[_text_]`, currentColorHex: parsedColor.hex, colorInfo: parsedColor, el: node, attributeName: null, isColor: true }); }
                    }
                }
            }
            if (doc.documentElement) traverse(doc.documentElement);
            return { doc, items };
        }

        // --- Rendering Functions ---
        function renderPalette() {
            const div = document.getElementById('paletteColors');
            if (!div) { console.error("renderPalette: paletteColors element not found."); return; }
            div.innerHTML = '';
            const isEditorLightTheme = document.body.classList.contains('light-theme');

            palette.forEach(c => {
                const colorHexNoHash = c.hex;
                const d = document.createElement('div');
                d.className = 'palette-color' + (selectedPaletteColor && selectedPaletteColor.hex === colorHexNoHash ? ' selected' : '');
                d.title = (c.name || 'Color') + ' #' + colorHexNoHash;
                d.style.background = '#' + colorHexNoHash;
                d.draggable = true;
                d.ondragstart = (e) => { e.dataTransfer.setData('text/plain', colorHexNoHash); };
                d.onclick = () => { selectedPaletteColor = { name: c.name, hex: colorHexNoHash }; renderPalette(); updateButtonStates(); };
                const label = document.createElement('div');
                label.textContent = '#' + colorHexNoHash;
                label.style.fontSize = '10px'; label.style.textAlign = 'center';
                label.style.color = '#' + colorHexNoHash;
                label.style.marginTop = '2px';
                const wrapper = document.createElement('div');
                wrapper.style.display = 'flex'; wrapper.style.flexDirection = 'column'; wrapper.style.alignItems = 'center';
                wrapper.appendChild(d); wrapper.appendChild(label);
                div.appendChild(wrapper);
            });
            const br = document.createElement('div');
            br.style.width = '100%'; br.style.height = '8px';
            div.appendChild(br);
            const grayHexesWithHash = ['#FFFFFF', '#EEEEEE', '#DDDDDD', '#CCCCCC', '#BBBBBB', '#AAAAAA', '#999999', '#888888', '#777777', '#666666', '#555555', '#444444', '#333333', '#222222', '#111111', '#000000'];
            grayHexesWithHash.forEach(grayHexWithHash => {
                const grayHexNoHash = grayHexWithHash.replace('#', '');
                const d = document.createElement('div');
                d.className = 'palette-color' + (selectedPaletteColor && selectedPaletteColor.hex === grayHexNoHash ? ' selected' : '');
                d.title = grayHexWithHash; d.style.background = grayHexWithHash; d.draggable = true;
                d.ondragstart = (e) => { e.dataTransfer.setData('text/plain', grayHexNoHash); };
                d.onclick = () => { selectedPaletteColor = { name: grayHexWithHash, hex: grayHexNoHash }; renderPalette(); updateButtonStates(); };
                const label = document.createElement('div');
                label.textContent = grayHexWithHash; label.style.fontSize = '10px'; label.style.textAlign = 'center';
                const labelTextColor = isEditorLightTheme ? '#000000' : '#FFFFFF';
                label.style.color = labelTextColor; label.style.marginTop = '2px';
                const wrapper = document.createElement('div');
                wrapper.style.display = 'flex'; wrapper.style.flexDirection = 'column'; wrapper.style.alignItems = 'center';
                wrapper.appendChild(d); wrapper.appendChild(label);
                div.appendChild(wrapper);
            });
        }

        // --- Filter and Render Theme Items ---
        function renderThemeItems() {
            const themeColorsDiv = document.getElementById('themeColors');
            if (!themeColorsDiv) { console.error("renderThemeItems: themeColors element not found."); return; }
            themeColorsDiv.innerHTML = '';

            filteredThemeItems.forEach((item) => {
                if (!item.isColor) return;

                const row = document.createElement('div');
                row.className = 'color-row';

                row.ondragover = (e) => {
                    e.preventDefault();
                };
                row.ondrop = (e) => {
                    e.preventDefault();
                    const droppedHexNoHash = e.dataTransfer.getData('text/plain');

                    if (!/^[0-9A-F]{6}$/i.test(droppedHexNoHash)) {
                        console.error("Invalid data dropped:", droppedHexNoHash);
                        return;
                    }

                    const newGc = new GoatColor('#' + droppedHexNoHash);
                    if (!newGc.isValid() || !item.colorInfo) {
                        console.error("Dropped color is invalid or item.colorInfo is missing.");
                        return;
                    }

                    item.currentColorHex = droppedHexNoHash.toUpperCase();
                    item.colorInfo.goatColor = newGc; // Assign GoatColor instance
                    item.colorInfo.hex = item.currentColorHex;
                    item.colorInfo.alpha = newGc.a; // Update alpha from GoatColor instance

                    const formattedValue = formatColorForOutput(item.colorInfo);
                    if (item.attributeName) {
                        item.el.setAttribute(item.attributeName, formattedValue);
                    } else {
                        item.el.textContent = formattedValue;
                    }
                    renderThemeItems();
                    updateButtonStates();
                };

                const swatchDiv = document.createElement('div');
                swatchDiv.className = 'color-sample';
                swatchDiv.style.backgroundColor = '#' + item.currentColorHex;
                swatchDiv.style.position = 'relative';

                const colorInput = document.createElement('input');
                colorInput.type = 'color';
                colorInput.value = '#' + item.currentColorHex;
                colorInput.style.opacity = 0;
                colorInput.style.position = 'absolute';
                colorInput.style.left = '0'; colorInput.style.top = '0';
                colorInput.style.width = '100%'; colorInput.style.height = '100%';
                colorInput.style.cursor = 'pointer';
                colorInput.oninput = (e) => {
                    const newHexFromPicker = e.target.value; // This is #RRGGBB
                    const newGcFromPicker = new GoatColor(newHexFromPicker);
                    if (newGcFromPicker.isValid() && item.colorInfo) {
                        const newHexRRGGBB = newGcFromPicker.toHex().substring(1).toUpperCase();
                        item.currentColorHex = newHexRRGGBB;
                        item.colorInfo.goatColor = newGcFromPicker; // Assign GoatColor instance
                        item.colorInfo.hex = newHexRRGGBB;
                        item.colorInfo.alpha = newGcFromPicker.a; // Update alpha
                    }
                    const formattedValue = formatColorForOutput(item.colorInfo);
                    if (item.attributeName) {
                        item.el.setAttribute(item.attributeName, formattedValue);
                    } else {
                        item.el.textContent = formattedValue;
                    }
                    renderThemeItems();
                };
                swatchDiv.appendChild(colorInput);
                swatchDiv.onclick = () => colorInput.click();
                row.appendChild(swatchDiv);

                let styleName = "";
                let attrKey = "";
                const match = item.name.match(/^(.*?)\[(.*?)\](?:_idx\d+)?$/);
                if (match) {
                    styleName = match[1]; attrKey = match[2];
                    if (attrKey === "_text_") { attrKey = ""; }
                } else {
                    styleName = item.name.replace(/_idx\d+$/, "");
                    if (item.attributeName) { attrKey = item.attributeName; }
                }

                const styleNameSpan = document.createElement('span');
                styleNameSpan.textContent = styleName.trim();
                styleNameSpan.title = styleName.trim();
                styleNameSpan.style.color = 'var(--text-body)';
                row.appendChild(styleNameSpan);

                const colorAttrKeySpan = document.createElement('span');
                colorAttrKeySpan.textContent = attrKey;
                colorAttrKeySpan.style.color = 'var(--text-body)';
                row.appendChild(colorAttrKeySpan);

                const valueDetailsSpan = document.createElement('span');
                const originalValueText = formatColorForOutput(item.colorInfo);
                const hexValueText = `#${item.currentColorHex}`;
                let displayText = `${originalValueText} (hex: ${hexValueText}`;
                if (item.colorInfo && item.colorInfo.alpha < 1) { displayText += ` A:${item.colorInfo.alpha.toFixed(2)}`; }
                displayText += `)`;
                valueDetailsSpan.textContent = displayText;
                valueDetailsSpan.style.color = '#' + item.currentColorHex;

                const rowEffectiveBgColor = getComputedStyle(row).backgroundColor;
                const contrastWithRowBg = calculateContrastRatio('#' + item.currentColorHex, rowEffectiveBgColor);
                if (contrastWithRowBg < 3) {
                    if (getRelativeLuminance('#' + item.currentColorHex) > 0.5) { valueDetailsSpan.style.backgroundColor = 'rgba(75, 75, 75, 0.67)'; }
                    else { valueDetailsSpan.style.backgroundColor = 'rgba(220, 220, 220, 0.67)'; }
                } else { valueDetailsSpan.style.backgroundColor = 'transparent'; }

                valueDetailsSpan.style.padding = '2px 6px';
                valueDetailsSpan.style.borderRadius = '3px';
                row.appendChild(valueDetailsSpan);

                themeColorsDiv.appendChild(row);
            });
            updateButtonStates();
        }


        // --- Filtering ---
        function filterThemeItems() {
            const filterInput = document.getElementById('filterInput');
            if (!filterInput) { console.error("filterThemeItems: filterInput not found."); return; }
            const filterText = filterInput.value.trim().toLowerCase();

            if (filterText) {
                filteredThemeItems = themeItems.filter(item =>
                    item.isColor && item.name.toLowerCase().includes(filterText)
                );
            } else {
                filteredThemeItems = themeItems.filter(item => item.isColor);
            }
            filteredThemeItems.sort((a, b) => a.name.localeCompare(b.name));
            renderThemeItems();
        }

        // --- EXPORT FUNCTION DEFINITION ---
        function exportXml() {
            console.log("exportXml function called.");
            if (!themeFileDoc) {
                console.warn("ExportXML called but no themeFileDoc loaded.");
                alert("No theme file loaded to export.");
                return;
            }

            function escapeXml(unsafeStr) {
                const str = String(unsafeStr); // Ensure it's a string
                // The order of replacements is important: & must be done first.
                return str.replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&apos;');
            }

            function formatNode(node, indentLevel) {
                let xml = '';
                const indentStr = '    ';
                const currentIndent = indentStr.repeat(indentLevel);

                switch (node.nodeType) {
                    case Node.ELEMENT_NODE:
                        xml += '\r\n' + currentIndent + '<' + node.nodeName;
                        for (let i = 0; i < node.attributes.length; i++) {
                            const attr = node.attributes[i];
                            xml += ` ${attr.name}="${escapeXml(attr.value)}"`;
                        }

                        if (node.childNodes.length === 0) {
                            // Truly empty element: <Tag></Tag>
                            xml += `></${node.nodeName}>`;
                        } else {
                            // Element has children, determine formatting style
                            let useMultilineFormat = false;
                            for (let i = 0; i < node.childNodes.length; i++) {
                                const childType = node.childNodes[i].nodeType;
                                if (childType === Node.ELEMENT_NODE || childType === Node.COMMENT_NODE) {
                                    useMultilineFormat = true;
                                    break;
                                }
                            }

                            if (useMultilineFormat) {
                                // Contains nested elements or comments: use multi-line indented format
                                xml += `>`;
                                for (let i = 0; i < node.childNodes.length; i++) {
                                    // Recursive call will handle indentation and newlines for children
                                    xml += formatNode(node.childNodes[i], indentLevel + 1);
                                }
                                xml += '\r\n' + currentIndent + `</${node.nodeName}>`;
                            } else {
                                // Only contains TEXT_NODE and/or CDATA_SECTION_NODE children: use single-line format
                                xml += `>`;
                                let simpleContent = '';
                                for (let i = 0; i < node.childNodes.length; i++) {
                                    const child = node.childNodes[i];
                                    if (child.nodeType === Node.TEXT_NODE) {
                                        simpleContent += escapeXml(child.nodeValue); // Get raw text value
                                    } else if (child.nodeType === Node.CDATA_SECTION_NODE) {
                                        simpleContent += `<![CDATA[${child.nodeValue}]]>`;
                                    }
                                    // Other node types (like PIs) inside such a "simple content" block are rare for UDL
                                    // and this logic assumes they are not present or don't affect this formatting choice.
                                }
                                xml += simpleContent;
                                xml += `</${node.nodeName}>`; // Closing tag on the same line
                            }
                        }
                        break; // End of case Node.ELEMENT_NODE
                    case Node.TEXT_NODE:
                        if (node.nodeValue.trim() !== '') { xml += escapeXml(node.nodeValue); }
                        break;
                    case Node.COMMENT_NODE:
                        xml += '\r\n' + currentIndent + `<!--${node.nodeValue}-->`;
                        break;
                    case Node.DOCUMENT_TYPE_NODE:
                        let dtString = '<!DOCTYPE ' + node.name;
                        if (node.publicId) dtString += ` PUBLIC "${node.publicId}"`;
                        if (!node.publicId && node.systemId) dtString += ' SYSTEM';
                        if (node.systemId) dtString += ` "${node.systemId}"`;
                        dtString += '>';
                        xml += '\r\n' + (indentLevel > 0 ? currentIndent : '') + dtString;
                        break;
                    case Node.PROCESSING_INSTRUCTION_NODE:
                        if (node.target.toLowerCase() !== "xml") { xml += '\r\n' + (indentLevel > 0 ? currentIndent : '') + `<?${node.target} ${node.data}?>`; }
                        break;
                    case Node.CDATA_SECTION_NODE:
                        xml += `<![CDATA[${node.nodeValue}]]>`;
                        break;
                }
                return xml;
            }

            let xmlDeclaration = '<?xml version="1.0" encoding="UTF-8"?>';
            let leadingContent = '';
            for (let i = 0; i < themeFileDoc.childNodes.length; i++) {
                const child = themeFileDoc.childNodes[i];
                if (child.nodeType === Node.PROCESSING_INSTRUCTION_NODE && child.target.toLowerCase() === "xml") { xmlDeclaration = `<?${child.target} ${child.data}?>`; }
                else if (child !== themeFileDoc.documentElement) { leadingContent += formatNode(child, 0); }
            }
            let formattedRoot = formatNode(themeFileDoc.documentElement, 0);
            if (formattedRoot.startsWith('\r\n')) { formattedRoot = formattedRoot.substring(2); }
            let prettyXml = xmlDeclaration + (leadingContent ? leadingContent + '\r\n' : '\r\n') + formattedRoot;

            const now = new Date();
            const pad = n => String(n).padStart(2, '0');
            const y = now.getFullYear().toString().slice(-2);
            const m = pad(now.getMonth() + 1);
            const d = pad(now.getDate());
            const H = pad(now.getHours());
            const M = pad(now.getMinutes());
            const filename = `${originalThemeFileName}.${y}${m}${d}${H}${M}.xml`;

            const blob = new Blob([prettyXml], { type: 'application/xml;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob); a.download = filename;
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
        }

        // --- Event Listener Setup (Enhanced with Logging and Error Handling) ---
        const importPaletteBtn = document.getElementById('importPaletteBtn');
        const paletteFileEl = document.getElementById('paletteFile');
        const paletteFileNameEl = document.getElementById('paletteFileName');
        const importThemeBtn = document.getElementById('importThemeBtn');
        const themeFileEl = document.getElementById('themeFile');
        const themeFileNameEl = document.getElementById('themeFileName');
        const filterInputElement = document.getElementById('filterInput');
        const bulkAssignBtnElement = document.getElementById('bulkAssignBtn');
        const exportBtnElement = document.getElementById('exportBtn');

        if (themeToggleBtn) {
            themeToggleBtn.onclick = () => {
                if (document.body.classList.contains('light-theme')) {
                    applyTheme('dark');
                } else {
                    applyTheme('light');
                }
            };
        } else {
            console.error("Theme toggle button not found!");
        }

        if (importPaletteBtn && paletteFileEl && paletteFileNameEl) {
            importPaletteBtn.onclick = () => { paletteFileEl.value = null; paletteFileEl.click(); };
            paletteFileEl.onchange = function (e) {
                const file = e.target.files[0];
                if (!file) { paletteFileNameEl.textContent = 'No palette file selected'; return; }
                paletteFileNameEl.textContent = file.name;
                const reader = new FileReader();
                reader.onload = function (ev) {
                    try {
                        if (ev.target.result) {
                            palette = parsePalette(ev.target.result); renderPalette(); updateButtonStates();
                        } else { alert("Error: Palette file content is empty or unreadable."); }
                    } catch (error) { alert(`Error processing palette file: ${error.message}`); }
                };
                reader.onerror = function () { alert(`Error reading palette file: ${reader.error ? reader.error.message : 'Unknown error'}`); };
                try {
                    reader.readAsText(file);
                } catch (readError) { alert(`Could not start reading palette file: ${readError.message}`); }
            };
        } else { console.error("Could not find all required DOM elements for palette import!"); }

        if (importThemeBtn && themeFileEl && themeFileNameEl) {
            importThemeBtn.onclick = () => { themeFileEl.value = null; themeFileEl.click(); };
            themeFileEl.onchange = function (e) {
                const file = e.target.files[0];
                if (!file) { themeFileNameEl.textContent = 'No theme file selected'; originalThemeFileName = "Theme"; themeItems = []; themeFileDoc = null; filterThemeItems(); return; }
                themeFileNameEl.textContent = file.name;
                const nameParts = file.name.split('.'); if (nameParts.length > 1) nameParts.pop(); originalThemeFileName = nameParts.join('.') || file.name;
                const reader = new FileReader();
                reader.onload = function (ev) {
                    try {
                        if (ev.target.result) {
                            const result = parseGenericThemeFile(ev.target.result); themeFileDoc = result.doc; themeItems = result.items;
                            themeItems.sort((a, b) => a.name.localeCompare(b.name));
                            filterThemeItems();
                        } else { alert("Error: Theme file content is empty or unreadable."); }
                    } catch (error) { alert(`Error processing theme file: ${error.message}`); }
                };
                reader.onerror = function () { alert(`Error reading theme file: ${reader.error ? reader.error.message : 'Unknown error'}`); };
                try {
                    reader.readAsText(file);
                } catch (readError) { alert(`Could not start reading theme file: ${readError.message}`); }
            };
        } else { console.error("Could not find all required DOM elements for theme import!"); }

        if (filterInputElement) {
            filterInputElement.oninput = filterThemeItems;
        } else { console.error("Filter input element not found!"); }

        if (bulkAssignBtnElement) {
            bulkAssignBtnElement.onclick = function () {
                if (!selectedPaletteColor || !selectedPaletteColor.hex || filteredThemeItems.length === 0) { return; }
                const newHexColorRRGGBB = selectedPaletteColor.hex;
                const newGcBase = new GoatColor('#' + newHexColorRRGGBB); // Base GoatColor for properties
                if (!newGcBase.isValid()) { console.error("Selected palette color for bulk assign is invalid:", newHexColorRRGGBB); return; }

                filteredThemeItems.forEach(item => {
                    if (!item.isColor || !item.colorInfo) return;
                    item.currentColorHex = newHexColorRRGGBB;
                    item.colorInfo.goatColor = new GoatColor('#' + newHexColorRRGGBB); // New instance for each item
                    item.colorInfo.hex = newHexColorRRGGBB;
                    item.colorInfo.alpha = item.colorInfo.goatColor.a; // Alpha from the new color instance

                    const formattedValue = formatColorForOutput(item.colorInfo);
                    if (item.attributeName) { item.el.setAttribute(item.attributeName, formattedValue); } else { item.el.textContent = formattedValue; }
                });
                renderThemeItems();
            };
        } else { console.error("Bulk Assign button element not found!"); }

        if (exportBtnElement) {
            exportBtnElement.onclick = exportXml;
        } else { console.error("Export button element not found!"); }

        // Initial Setup Calls
        const initialTheme = localStorage.getItem('themeEditorTheme') || 'dark';
        applyTheme(initialTheme);
        updateButtonStates();
        renderPalette(); // Render default palette (grays) even if no file loaded
        renderThemeItems();
    </script>

    <script>
        /*
    * goatColor - A compact, performant color conversion library for Hex, RGB, HSL, and OKLCH.
    * @author Bluff McCougar
    * @version 20250510.1230
    * @license MIT
    * Supports parsing modern and legacy CSS Color Module Level 4 syntax, including named colors.
    * OKLCH conversion based on Bjrn Ottosson's specification.
 */

        /* --- Example Usage ---
        
        ** Basic instantiation (factory or constructor) **
        const color1 = goatcolor("#ff0000");      // Opaque red
        const color2 = new GoatColor("rgba(0, 128, 255, 0.5)"); // Semi-transparent blue
        
        ** Check validity **
        console.log(color1.isValid()); // true
        console.log(goatcolor("invalid").isValid()); // false
        
        ** Output to different formats **
        console.log(color1.toHex());         // "#ff0000"
        console.log(color1.toRgbString());   // "rgb(255 0 0)"
        console.log(color1.toHsl());         // { h: 0, s: 100, l: 50 }
        console.log(color1.toOklchString()); // "oklch(62.79% 0.2577 29.23)"
        
        console.log(color2.toHexa());        // "#0080ff80"
        console.log(color2.toRgbaString(true)); // "rgba(0, 128, 255, 0.5)" (legacy comma format)
        console.log(color2.toHsla());        // { h: 210, s: 100, l: 50, a: 0.5 }
        
        ** Smart toString() output (prefers shorter hex if possible) **
        const color3 = goatcolor("green");
        console.log(color3.toString());      // "#008000" (green is #008000, not shortable)
        const color4 = goatcolor("#123");    // Short hex input
        console.log(color4.toString());      // "#112233"
        const color5 = goatcolor("#aabbccdd");
        console.log(color5.toString('auto')); // "#abcd" (short hex with alpha)
        const color6 = goatcolor("oklch(70% 0.1 50 / 0.8)");
        console.log(color6.toString());       // "#a4a066cc" (output preference: hexaShort or hexa)
        
        ** Parsing various CSS syntaxes **
        const fromHsl = goatcolor("hsl(270 60% 70% / 0.9)"); // Modern HSL with alpha
        console.log(fromHsl.toRgba()); // { r: 191, g: 143, b: 224, a: 0.9 }
        
        const fromOklch = goatcolor("oklch(0.8 0.15 240)"); // OKLCH L as number
        console.log(fromOklch.toRgbString()); // "rgb(165 194 255)"
        
        ** Static validation **
        console.log(goatcolor.isValidColorString("blue"));       // true
        console.log(goatcolor.isValidColorString("rgb(300 0 0)")); // true (values are clamped)
        console.log(goatcolor.isValidColorString("hsl(bad H S L)")); // false
        
        ** Access named colors map **
        console.log(goatcolor.cssNamedColors.rebeccapurple); // "#663399"
        
        */

        //-----------------------------------------------------------------------------
        (function (global, factory) {
            typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
                typeof define === 'function' && define.amd ? define(factory) :
                    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.GoatColor = factory());
        }(this, (function () {
            'use strict';

            // --- Constants for OKLCH Conversion ---
            // sRGB Linear -> LMS (Bradford adapted Cat02)
            const SRGB_TO_LMS = [
                [+0.4123907993, +0.3575843394, +0.1804807884],
                [+0.2126390059, +0.7151686788, +0.0721923154],
                [+0.0193308187, +0.1191947798, +0.9505321522],
            ];
            // LMS -> sRGB Linear
            const LMS_TO_SRGB = [
                [+3.2409699420, -1.5373831776, -0.4986107603],
                [-0.9692436363, +1.8759675015, +0.0415550574],
                [+0.0556300797, -0.2039769589, +1.0569715142],
            ];

            // --- Helper Functions ---
            const trim = (s) => s && typeof s === 'string' ? s.trim() : '';
            const clamp = (val, min, max) => Math.max(min, Math.min(val, max));
            const round = (num, places = 6) => Math.round(num * (10 ** places)) / (10 ** places);
            const isPercent = (valStr) => typeof valStr === 'string' && valStr.endsWith('%');

            // Parses R, G, B values (0-255 or 0%-100%) into 0-255 range.
            function parseRgbUnit(unitValStr) {
                const str = String(unitValStr); // Ensure it's a string for isPercent
                if (isPercent(str)) {
                    return clamp(parseFloat(str) * 2.55, 0, 255);
                }
                return clamp(parseFloat(str), 0, 255);
            }

            // Parses H value (deg, rad, grad, turn, or no unit) into degrees (0-360).
            function parseHue(hueValStr) {
                const hueStr = String(hueValStr).toLowerCase().trim();
                const numVal = parseFloat(hueStr);
                if (isNaN(numVal)) return 0; // Invalid number

                if (hueStr.endsWith('deg') || !/[a-z]$/.test(hueStr)) return numVal % 360; // Default unit is degrees
                if (hueStr.endsWith('rad')) return (numVal * 180 / Math.PI) % 360;
                if (hueStr.endsWith('grad')) return (numVal * 0.9) % 360;
                if (hueStr.endsWith('turn')) return (numVal * 360) % 360;
                return 0; // Should not be reached if !/[a-z]$/ covers unitless
            }

            // Parses HSL Saturation or Lightness percentage (0%-100%) into 0-100 range.
            // CSS Spec: S and L must be percentages.
            function parseSaturationLightness(slValStr) {
                const str = String(slValStr);
                if (!isPercent(str)) {
                    throw new Error("Saturation/Lightness components in HSL must be percentages (e.g., '50%').");
                }
                const numVal = parseFloat(str); // "50%" becomes 50
                return clamp(numVal, 0, 100);
            }

            // Parses Alpha (0-1 or 0%-100%) into 0-1 range.
            function parseAlpha(alphaVal) {
                if (alphaVal === undefined || alphaVal === null) return 1;
                const strVal = String(alphaVal).trim();
                if (strVal === '') return 1; // Empty string for alpha also defaults to 1

                if (isPercent(strVal)) {
                    return clamp(parseFloat(strVal), 0, 100) / 100;
                }
                return clamp(parseFloat(strVal), 0, 1);
            }

            // Parses OKLCH Lightness (L) component.
            // L can be a number (0-1, interpreted as 0-100%) or a percentage string (0%-100%).
            function parseOklchL(lValStr) {
                const str = String(lValStr);
                const numVal = parseFloat(str);
                if (isNaN(numVal)) throw new Error("Invalid OKLCH Lightness value.");

                if (isPercent(str)) {
                    return clamp(numVal, 0, 100); // e.g., "60%" -> 60
                }
                // If number, spec says 0.4 means 40%. Scale 0-1 to 0-100.
                return clamp(numVal * 100, 0, 100); // e.g., "0.6" -> 60
            }

            // Parses OKLCH Chroma (C) component.
            // C can be a number (typically 0-0.4, can be larger) or a percentage (relative to 0.4, so 100% = 0.4).
            function parseOklchC(cValStr) {
                const str = String(cValStr);
                const numVal = parseFloat(str);
                if (isNaN(numVal)) throw new Error("Invalid OKLCH Chroma value.");

                if (isPercent(str)) {
                    // Percentage is relative to 0.4 (100% = 0.4)
                    return clamp((numVal / 100) * 0.4, 0, Infinity); // Chroma can be > 0.4
                }
                // If number, it's a direct value
                return clamp(numVal, 0, Infinity);
            }


            // Converts 0-255 value to 2-digit hex
            function valToHex(compVal) {
                return Math.round(clamp(compVal, 0, 255)).toString(16).padStart(2, '0');
            }

            // sRGB Companding (gamma correction)
            function srgbCompToLinear(compVal) {
                const normVal = compVal / 255;
                return normVal <= 0.04045 ? normVal / 12.92 : Math.pow((normVal + 0.055) / 1.055, 2.4);
            }

            // Inverse sRGB Companding
            function linearCompToSrgb(linearVal) {
                const comp = linearVal <= 0.0031308 ? linearVal * 12.92 : 1.055 * Math.pow(linearVal, 1 / 2.4) - 0.055;
                return Math.round(clamp(comp, 0, 1) * 255);
            }

            // Matrix multiplication helper
            function multiplyMatrix(matrix, vector) {
                return [
                    matrix[0][0] * vector[0] + matrix[0][1] * vector[1] + matrix[0][2] * vector[2],
                    matrix[1][0] * vector[0] + matrix[1][1] * vector[1] + matrix[1][2] * vector[2],
                    matrix[2][0] * vector[0] + matrix[2][1] * vector[1] + matrix[2][2] * vector[2],
                ];
            }

            // --- Core Conversion Logic ---
            function rgbToHsl(r_in, g_in, b_in) {
                const r_norm = r_in / 255, g_norm = g_in / 255, b_norm = b_in / 255;
                const max_val = Math.max(r_norm, g_norm, b_norm), min_val = Math.min(r_norm, g_norm, b_norm);
                let h_out = 0, s_out = 0, l_out = (max_val + min_val) / 2;

                if (max_val === min_val) {
                    h_out = s_out = 0; // achromatic
                } else {
                    const diff = max_val - min_val;
                    s_out = l_out > 0.5 ? diff / (2 - max_val - min_val) : diff / (max_val + min_val);
                    switch (max_val) {
                        case r_norm: h_out = (g_norm - b_norm) / diff + (g_norm < b_norm ? 6 : 0); break;
                        case g_norm: h_out = (b_norm - r_norm) / diff + 2; break;
                        case b_norm: h_out = (r_norm - g_norm) / diff + 4; break;
                    }
                    h_out /= 6;
                }
                return { h: h_out * 360, s: s_out * 100, l: l_out * 100 };
            }

            function hslToRgb(h_in, s_in, l_in) { // h:0-360, s:0-100, l:0-100
                const h_norm = ((h_in % 360) + 360) % 360 / 360; // Ensure h is in [0,1)
                const s_norm = clamp(s_in, 0, 100) / 100;
                const l_norm = clamp(l_in, 0, 100) / 100;
                let r_out, g_out, b_out;

                if (s_norm === 0) {
                    r_out = g_out = b_out = l_norm; // achromatic
                } else {
                    const hue2rgb = (p_val, q_val, t_hue) => {
                        if (t_hue < 0) t_hue += 1;
                        if (t_hue > 1) t_hue -= 1;
                        if (t_hue < 1 / 6) return p_val + (q_val - p_val) * 6 * t_hue;
                        if (t_hue < 1 / 2) return q_val;
                        if (t_hue < 2 / 3) return p_val + (q_val - p_val) * (2 / 3 - t_hue) * 6;
                        return p_val;
                    };
                    const q_term = l_norm < 0.5 ? l_norm * (1 + s_norm) : l_norm + s_norm - l_norm * s_norm;
                    const p_term = 2 * l_norm - q_term;
                    r_out = hue2rgb(p_term, q_term, h_norm + 1 / 3);
                    g_out = hue2rgb(p_term, q_term, h_norm);
                    b_out = hue2rgb(p_term, q_term, h_norm - 1 / 3);
                }
                return { r: Math.round(r_out * 255), g: Math.round(g_out * 255), b: Math.round(b_out * 255) };
            }

            function rgbToOklch(r_in, g_in, b_in) {
                const r_linear = srgbCompToLinear(r_in);
                const g_linear = srgbCompToLinear(g_in);
                const b_linear = srgbCompToLinear(b_in);

                const [l_cone, m_cone, s_cone] = multiplyMatrix(SRGB_TO_LMS, [r_linear, g_linear, b_linear]);

                const l_prime = Math.cbrt(l_cone);
                const m_prime = Math.cbrt(m_cone);
                const s_prime = Math.cbrt(s_cone);

                const oklab_L = 0.2104542553 * l_prime + 0.7936177850 * m_prime - 0.0040720468 * s_prime;
                const oklab_a = 1.9779984951 * l_prime - 2.4285922050 * m_prime + 0.4505937099 * s_prime;
                const oklab_b = 0.0259040371 * l_prime + 0.7827717662 * m_prime - 0.8086757660 * s_prime;

                const oklch_C = Math.sqrt(oklab_a * oklab_a + oklab_b * oklab_b);
                let oklch_H = Math.atan2(oklab_b, oklab_a) * 180 / Math.PI;
                if (oklch_H < 0) oklch_H += 360;

                return { l: oklab_L * 100, c: oklch_C, h: oklch_H }; // L: 0-100
            }

            function oklchToRgb(L_in, C_in, H_in) { // L: 0-100, C: number, H: 0-360
                const L_norm = clamp(L_in, 0, 100) / 100; // Scale L to 0-1 for calculations
                const C_norm = clamp(C_in, 0, Infinity);  // Ensure C is non-negative
                const H_rad = (((H_in % 360) + 360) % 360) * Math.PI / 180; // Ensure H is [0, 360) then to rad

                const oklab_a = C_norm * Math.cos(H_rad);
                const oklab_b = C_norm * Math.sin(H_rad);

                const l_prime = L_norm + 0.3963377774 * oklab_a + 0.2158037573 * oklab_b;
                const m_prime = L_norm - 0.1055613458 * oklab_a - 0.0638541728 * oklab_b;
                const s_prime = L_norm - 0.0894841775 * oklab_a - 1.2914855480 * oklab_b;

                const l_cone = l_prime * l_prime * l_prime;
                const m_cone = m_prime * m_prime * m_prime;
                const s_cone = s_prime * s_prime * s_prime;

                const [r_linear, g_linear, b_linear] = multiplyMatrix(LMS_TO_SRGB, [l_cone, m_cone, s_cone]);

                const r_out = linearCompToSrgb(r_linear);
                const g_out = linearCompToSrgb(g_linear);
                const b_out = linearCompToSrgb(b_linear);

                return { r: r_out, g: g_out, b: b_out };
            }

            // --- Regex for Parsing ---
            // rgb(255 100 0 / 0.5), rgb(100% 50% 0% / 50%)
            const RGB_SPACE_REGEX = /^rgba?\(\s*([+\-\d.%]+)\s+([+\-\d.%]+)\s+([+\-\d.%]+)\s*(?:\/\s*([+\-\d.%]+)\s*)?\)$/i;
            // rgb(255, 100, 0), rgba(255, 100, 0, 0.5)
            const RGB_COMMA_REGEX = /^rgba?\(\s*([+\-\d.%]+)\s*,\s*([+\-\d.%]+)\s*,\s*([+\-\d.%]+)\s*(?:,\s*([+\-\d.%]+)\s*)?\)$/i;
            // hsl(120 100% 50% / 0.5), hsl(0.5turn 80% 40% / 80%)
            const HSL_SPACE_REGEX = /^hsla?\(\s*([+\-\d.%a-z]+)\s+([+\-\d.%]+)\s+([+\-\d.%]+)\s*(?:\/\s*([+\-\d.%]+)\s*)?\)$/i;
            // hsl(120, 100%, 50%), hsla(120, 100%, 50%, 0.5)
            const HSL_COMMA_REGEX = /^hsla?\(\s*([+\-\d.%a-z]+)\s*,\s*([+\-\d.%]+)\s*,\s*([+\-\d.%]+)\s*(?:,\s*([+\-\d.%]+)\s*)?\)$/i;
            // #rgb, #rgba, #rrggbb, #rrggbbaa
            const HEX_REGEX = /^#?([a-f\d]{1})([a-f\d]{1})([a-f\d]{1})([a-f\d]{1})?$|^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i;
            // 0xRRGGBB, 0xAARRGGBB
            const HEX_0X_REGEX = /^0x([a-f\d]{2})?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
            // oklch(40.1% 0.123 21.57 / 0.5) or oklch(0.401 25% 21.57 / 0.5)
            const OKLCH_REGEX = /^oklch\(\s*([+\-\d.%]+)\s+([+\-\d.%]+)\s+([+\-\d.%a-z]+)\s*(?:\/\s*([+\-\d.%]+)\s*)?\)$/i;

            // CSS W3C Named Colors (https://www.w3.org/TR/css-color-4/#named-colors)
            const CSS_NAMED_COLORS = {
                aliceblue: "#f0f8ff", antiquewhite: "#faebd7", aqua: "#00ffff", aquamarine: "#7fffd4", azure: "#f0ffff", beige: "#f5f5dc", bisque: "#ffe4c4", black: "#000000", blanchedalmond: "#ffebcd", blue: "#0000ff", blueviolet: "#8a2be2", brown: "#a52a2a", burlywood: "#deb887", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", cornflowerblue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", darkkhaki: "#bdb76b", darkmagenta: "#8b008b", darkolivegreen: "#556b2f", darkorange: "#ff8c00", darkorchid: "#9932cc", darkred: "#8b0000", darksalmon: "#e9967a", darkseagreen: "#8fbc8f", darkslateblue: "#483d8b", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", darkturquoise: "#00ced1", darkviolet: "#9400d3", deeppink: "#ff1493", deepskyblue: "#00bfff", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1e90ff", firebrick: "#b22222", floralwhite: "#fffaf0", forestgreen: "#228b22", fuchsia: "#ff00ff", gainsboro: "#dcdcdc", ghostwhite: "#f8f8ff", gold: "#ffd700", goldenrod: "#daa520", gray: "#808080", green: "#008000", greenyellow: "#adff2f", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", indianred: "#cd5c5c", indigo: "#4b0082", ivory: "#fffff0", khaki: "#f0e68c", lavender: "#e6e6fa", lavenderblush: "#fff0f5", lawngreen: "#7cfc00", lemonchiffon: "#fffacd", lightblue: "#add8e6", lightcoral: "#f08080", lightcyan: "#e0ffff", lightgoldenrodyellow: "#fafad2", lightgray: "#d3d3d3", lightgreen: "#90ee90", lightgrey: "#d3d3d3", lightpink: "#ffb6c1", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", lightskyblue: "#87cefa", lightslategray: "#778899", lightslategrey: "#778899", lightsteelblue: "#b0c4de", lightyellow: "#ffffe0", lime: "#00ff00", limegreen: "#32cd32", linen: "#faf0e6", magenta: "#ff00ff", maroon: "#800000", mediumaquamarine: "#66cdaa", mediumblue: "#0000cd", mediumorchid: "#ba55d3", mediumpurple: "#9370db", mediumseagreen: "#3cb371", mediumslateblue: "#7b68ee", mediumspringgreen: "#00fa9a", mediumturquoise: "#48d1cc", mediumvioletred: "#c71585", midnightblue: "#191970", mintcream: "#f5fffa", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", navajowhite: "#ffdead", navy: "#000080", oldlace: "#fdf5e6", olive: "#808000", olivedrab: "#6b8e23", orange: "#ffa500", orangered: "#ff4500", orchid: "#da70d6", palegoldenrod: "#eee8aa", palegreen: "#98fb98", paleturquoise: "#afeeee", palevioletred: "#db7093", papayawhip: "#ffefd5", peachpuff: "#ffdab9", peru: "#cd853f", pink: "#ffc0cb", plum: "#dda0dd", powderblue: "#b0e0e6", purple: "#800080", rebeccapurple: "#663399", red: "#ff0000", rosybrown: "#bc8f8f", royalblue: "#4169e1", saddlebrown: "#8b4513", salmon: "#fa8072", sandybrown: "#f4a460", seagreen: "#2e8b57", seashell: "#fff5ee", sienna: "#a0522d", silver: "#c0c0c0", skyblue: "#87ceeb", slateblue: "#6a5acd", slategray: "#708090", slategrey: "#708090", snow: "#fffafa", springgreen: "#00ff7f", steelblue: "#4682b4", tan: "#d2b48c", teal: "#008080", thistle: "#d8bfd8", tomato: "#ff6347", transparent: "#ffffff00", turquoise: "#40e0d0", violet: "#ee82ee", wheat: "#f5deb3", white: "#ffffff", whitesmoke: "#f5f5f5", yellow: "#ffff00", yellowgreen: "#9acd32"
            };

            // --- The Color Class ---
            class GoatColor {
                constructor(inputColorString) {
                    this.r = 0;
                    this.g = 0;
                    this.b = 0;
                    this.a = 1;
                    this.input = inputColorString; // Store original input
                    this.valid = false;
                    this._parse(inputColorString);
                }

                _parse(originalInput) {
                    if (typeof originalInput !== 'string' && originalInput !== null && typeof originalInput !== 'undefined') {
                        // Non-string, non-null/undefined input is invalid.
                        // this.input is already set by constructor.
                        return;
                    }

                    let effectiveInputStr = trim(String(originalInput)); // Work with a trimmed string version
                    if (!effectiveInputStr && originalInput !== null && typeof originalInput !== 'undefined') {
                        // Empty or whitespace-only string (but not null/undefined itself)
                        return; // Invalid
                    }
                    if (originalInput === null || typeof originalInput === 'undefined') {
                        return; // Invalid for null or undefined
                    }


                    // 0. Try Named Colors first
                    const lowerInput = effectiveInputStr.toLowerCase();
                    if (CSS_NAMED_COLORS.hasOwnProperty(lowerInput)) {
                        effectiveInputStr = CSS_NAMED_COLORS[lowerInput]; // Replace name with its hex value for further parsing
                    }

                    let regexMatch;

                    // 1. Try Hex (#...)
                    if ((regexMatch = effectiveInputStr.match(HEX_REGEX))) {
                        if (regexMatch[5] !== undefined) { // #RRGGBB or #RRGGBBAA
                            this.r = parseInt(regexMatch[5], 16);
                            this.g = parseInt(regexMatch[6], 16);
                            this.b = parseInt(regexMatch[7], 16);
                            this.a = regexMatch[8] ? parseInt(regexMatch[8], 16) / 255 : 1;
                            this.valid = true;
                        } else if (regexMatch[1] !== undefined) { // #RGB or #RGBA
                            this.r = parseInt(regexMatch[1] + regexMatch[1], 16);
                            this.g = parseInt(regexMatch[2] + regexMatch[2], 16);
                            this.b = parseInt(regexMatch[3] + regexMatch[3], 16);
                            this.a = regexMatch[4] ? parseInt(regexMatch[4] + regexMatch[4], 16) / 255 : 1;
                            this.valid = true;
                        }
                        if (this.valid) return;
                    }

                    // 2. Try 0x Hex (0x...)
                    if ((regexMatch = effectiveInputStr.match(HEX_0X_REGEX))) {
                        // regexMatch[1] is potential Alpha, regexMatch[2,3,4] are R,G,B
                        if (effectiveInputStr.length === 8 && regexMatch[1] === undefined) { // 0xRRGGBB
                            this.r = parseInt(regexMatch[2], 16);
                            this.g = parseInt(regexMatch[3], 16);
                            this.b = parseInt(regexMatch[4], 16);
                            this.a = 1;
                            this.valid = true;
                        } else if (effectiveInputStr.length === 10 && regexMatch[1] !== undefined) { // 0xAARRGGBB
                            this.a = parseInt(regexMatch[1], 16) / 255;
                            this.r = parseInt(regexMatch[2], 16);
                            this.g = parseInt(regexMatch[3], 16);
                            this.b = parseInt(regexMatch[4], 16);
                            this.valid = true;
                        }
                        if (this.valid) return;
                    }

                    // 3. Try OKLCH (oklch(...))
                    if ((regexMatch = effectiveInputStr.match(OKLCH_REGEX))) {
                        try {
                            const parsed_L_ok = parseOklchL(regexMatch[1]); // Parses L (0-1 or %) to 0-100 range
                            const parsed_C_ok = parseOklchC(regexMatch[2]); // Parses C (number or %) to numeric value
                            const parsed_H_ok = parseHue(regexMatch[3]);    // Parses Hue to 0-360 range
                            const parsed_A_ok = parseAlpha(regexMatch[4]);  // Parses Alpha to 0-1 range

                            // oklchToRgb expects L:0-100, C:number, H:0-360
                            const { r, g, b } = oklchToRgb(parsed_L_ok, parsed_C_ok, parsed_H_ok);
                            this.r = r;
                            this.g = g;
                            this.b = b;
                            this.a = parsed_A_ok;
                            this.valid = true;
                        } catch (e) {
                            // console.error("OKLCH Parse/Conversion Error:", e.message, "Input:", effectiveInputStr);
                            this.valid = false;
                        }
                        if (this.valid) return;
                    }

                    // 4. Try HSL Space (hsl(... ...))
                    if ((regexMatch = effectiveInputStr.match(HSL_SPACE_REGEX))) {
                        try {
                            const parsed_h = parseHue(regexMatch[1]);           // Returns 0-360
                            const parsed_s = parseSaturationLightness(regexMatch[2]); // Returns 0-100, throws if not %
                            const parsed_l = parseSaturationLightness(regexMatch[3]); // Returns 0-100, throws if not %
                            const parsed_alpha = parseAlpha(regexMatch[4]);     // Returns 0-1

                            // hslToRgb expects h:0-360, s:0-100, l:0-100
                            const { r, g, b } = hslToRgb(parsed_h, parsed_s, parsed_l);
                            this.r = r;
                            this.g = g;
                            this.b = b;
                            this.a = parsed_alpha;
                            this.valid = true;
                        } catch (e) {
                            // console.error("HSL (Space) Parse/Conversion Error:", e.message, "Input:", effectiveInputStr);
                            this.valid = false;
                        }
                        if (this.valid) return;
                    }

                    // 5. Try HSL Comma (hsl(..., ..., ...))
                    if ((regexMatch = effectiveInputStr.match(HSL_COMMA_REGEX))) {
                        try {
                            const parsed_h = parseHue(regexMatch[1]);
                            const parsed_s = parseSaturationLightness(regexMatch[2]);
                            const parsed_l = parseSaturationLightness(regexMatch[3]);
                            const parsed_alpha = parseAlpha(regexMatch[4]);

                            const { r, g, b } = hslToRgb(parsed_h, parsed_s, parsed_l);
                            this.r = r;
                            this.g = g;
                            this.b = b;
                            this.a = parsed_alpha;
                            this.valid = true;
                        } catch (e) {
                            // console.error("HSL (Comma) Parse/Conversion Error:", e.message, "Input:", effectiveInputStr);
                            this.valid = false;
                        }
                        if (this.valid) return;
                    }

                    // 6. Try RGB Space (rgb(... ...))
                    if ((regexMatch = effectiveInputStr.match(RGB_SPACE_REGEX))) {
                        try {
                            this.r = parseRgbUnit(regexMatch[1]); // Returns 0-255
                            this.g = parseRgbUnit(regexMatch[2]); // Returns 0-255
                            this.b = parseRgbUnit(regexMatch[3]); // Returns 0-255
                            this.a = parseAlpha(regexMatch[4]);   // Returns 0-1
                            if (isNaN(this.r) || isNaN(this.g) || isNaN(this.b) || isNaN(this.a)) throw new Error("Invalid RGB component");
                            this.valid = true;
                        } catch (e) {
                            // console.error("RGB (Space) Parse Error:", e.message, "Input:", effectiveInputStr);
                            this.valid = false;
                        }
                        if (this.valid) return;
                    }

                    // 7. Try RGB Comma (rgb(..., ..., ...))
                    if ((regexMatch = effectiveInputStr.match(RGB_COMMA_REGEX))) {
                        try {
                            this.r = parseRgbUnit(regexMatch[1]);
                            this.g = parseRgbUnit(regexMatch[2]);
                            this.b = parseRgbUnit(regexMatch[3]);
                            this.a = parseAlpha(regexMatch[4]);
                            if (isNaN(this.r) || isNaN(this.g) || isNaN(this.b) || isNaN(this.a)) throw new Error("Invalid RGB component");
                            this.valid = true;
                        } catch (e) {
                            // console.error("RGB (Comma) Parse Error:", e.message, "Input:", effectiveInputStr);
                            this.valid = false;
                        }
                        // if (this.valid) return; // Final check, not strictly needed before falling to invalid
                    }
                    // If no format matched or an error occurred, this.valid remains false.
                }

                isValid() {
                    return this.valid;
                }

                // --- Output Methods ---
                toRgb() {
                    return { r: Math.round(this.r), g: Math.round(this.g), b: Math.round(this.b) };
                }
                toRgba() {
                    return { r: Math.round(this.r), g: Math.round(this.g), b: Math.round(this.b), a: this.a };
                }

                toRgbString(legacyFormat = false) {
                    const { r, g, b } = this.toRgb();
                    return legacyFormat ? `rgb(${r}, ${g}, ${b})` : `rgb(${r} ${g} ${b})`;
                }
                toRgbaString(legacyFormat = false) {
                    const { r, g, b } = this.toRgb();
                    const alphaStr = round(this.a, 3).toString(); // Round alpha for cleaner output
                    if (legacyFormat) {
                        return `rgba(${r}, ${g}, ${b}, ${alphaStr})`;
                    }
                    return this.a === 1 ? `rgb(${r} ${g} ${b})` : `rgb(${r} ${g} ${b} / ${alphaStr})`;
                }

                toHex() {
                    return `#${valToHex(this.r)}${valToHex(this.g)}${valToHex(this.b)}`;
                }
                toHexa() {
                    return `#${valToHex(this.r)}${valToHex(this.g)}${valToHex(this.b)}${valToHex(this.a * 255)}`;
                }
                toHexShort() {
                    if (this.a < 1) return null;
                    const r_hex = valToHex(this.r);
                    const g_hex = valToHex(this.g);
                    const b_hex = valToHex(this.b);
                    if (r_hex[0] === r_hex[1] && g_hex[0] === g_hex[1] && b_hex[0] === b_hex[1]) {
                        return `#${r_hex[0]}${g_hex[0]}${b_hex[0]}`;
                    }
                    return null;
                }
                toHexaShort() {
                    const r_hex = valToHex(this.r);
                    const g_hex = valToHex(this.g);
                    const b_hex = valToHex(this.b);
                    const a_hex = valToHex(this.a * 255);
                    if (r_hex[0] === r_hex[1] && g_hex[0] === g_hex[1] && b_hex[0] === b_hex[1] && a_hex[0] === a_hex[1]) {
                        return `#${r_hex[0]}${g_hex[0]}${b_hex[0]}${a_hex[0]}`;
                    }
                    return null;
                }

                toHsl() {
                    const { h, s, l } = rgbToHsl(this.r, this.g, this.b);
                    return { h: round(h, 1), s: round(s, 1), l: round(l, 1) };
                }
                toHsla() {
                    const { h, s, l } = this.toHsl();
                    return { h: h, s: s, l: l, a: this.a };
                }

                // Helper for formatting HSL/OKLCH numbers, removing trailing .0, .00 etc.
                _formatFixed(num, places) {
                    let str = num.toFixed(places);
                    if (places > 0) {
                        str = str.replace(/\.?0+$/, ''); // Remove trailing .0, .00 etc.
                    }
                    return str;
                }

                toHslString(legacyFormat = false) {
                    const { h, s, l } = this.toHsl();
                    const hStr = this._formatFixed(h, 1);
                    const sStr = this._formatFixed(s, 1);
                    const lStr = this._formatFixed(l, 1);
                    return legacyFormat
                        ? `hsl(${hStr}, ${sStr}%, ${lStr}%)`
                        : `hsl(${hStr} ${sStr}% ${lStr}%)`;
                }
                toHslaString(legacyFormat = false) {
                    const { h, s, l } = this.toHsl();
                    const alphaStr = round(this.a, 3).toString();
                    const hStr = this._formatFixed(h, 1);
                    const sStr = this._formatFixed(s, 1);
                    const lStr = this._formatFixed(l, 1);

                    if (legacyFormat) {
                        return `hsla(${hStr}, ${sStr}%, ${lStr}%, ${alphaStr})`;
                    }
                    return this.a === 1
                        ? `hsl(${hStr} ${sStr}% ${lStr}%)`
                        : `hsl(${hStr} ${sStr}% ${lStr}% / ${alphaStr})`;
                }

                toOklch() {
                    const { l, c, h } = rgbToOklch(this.r, this.g, this.b);
                    return { l: round(l, 2), c: round(c, 4), h: round(h, 2) };
                }
                toOklcha() {
                    const { l, c, h } = this.toOklch();
                    return { l: l, c: c, h: h, a: this.a };
                }

                toOklchString() {
                    const { l, c, h } = this.toOklch();
                    const lStr = this._formatFixed(l, 2);
                    const cStr = this._formatFixed(c, 4);
                    const hStr = this._formatFixed(h, 2);
                    return `oklch(${lStr}% ${cStr} ${hStr})`; // L always needs %
                }
                toOklchaString() {
                    const { l, c, h } = this.toOklch();
                    const alphaStr = round(this.a, 3).toString();
                    const lStr = this._formatFixed(l, 2);
                    const cStr = this._formatFixed(c, 4);
                    const hStr = this._formatFixed(h, 2);

                    return this.a === 1
                        ? `oklch(${lStr}% ${cStr} ${hStr})`
                        : `oklch(${lStr}% ${cStr} ${hStr} / ${alphaStr})`;
                }

                toString(format = 'auto') {
                    if (!this.valid) return String(this.input); // Return original invalid input as string

                    const needsAlphaOutput = this.a < 1;
                    const shortHex = this.toHexShort();
                    const shortHexa = this.toHexaShort();

                    switch (format) {
                        case 'hex': return this.toHex();
                        case 'hexa': return this.toHexa();
                        case 'hexShort': return shortHex || this.toHex();
                        case 'hexaShort': return shortHexa || this.toHexa();
                        case 'rgb': return this.toRgbString();
                        case 'rgba': return this.toRgbaString();
                        case 'rgbLegacy': return this.toRgbString(true);
                        case 'rgbaLegacy': return this.toRgbaString(true);
                        case 'hsl': return this.toHslString();
                        case 'hsla': return this.toHslaString();
                        case 'hslLegacy': return this.toHslString(true);
                        case 'hslaLegacy': return this.toHslaString(true);
                        case 'oklch': return this.toOklchString();
                        case 'oklcha': return this.toOklchaString();
                        case 'auto':
                        default:
                            if (needsAlphaOutput) {
                                return shortHexa || this.toHexa(); // Prefer #RGBA or #RRGGBBAA
                            }
                            return shortHex || this.toHex(); // Prefer #RGB or #RRGGBB
                    }
                }
            }

            // Factory function for easier instantiation: goatcolor(...)
            function goatcolor(colorString) {
                return new GoatColor(colorString);
            }

            // Expose the class constructor on the factory function for potential extension
            goatcolor.GoatColor = GoatColor;

            // Expose named colors map
            goatcolor.cssNamedColors = CSS_NAMED_COLORS;

            // Static validation function
            goatcolor.isValidColorString = function (colorString) {
                // The most reliable way to check validity is to try parsing it.
                // This reuses all internal parsing and validation logic.
                return new GoatColor(colorString).isValid();
            };

            return goatcolor; // Export the factory function

        })));
    </script>

</body>

</html>